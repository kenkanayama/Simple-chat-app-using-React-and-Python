# やったこと
リアルタイムチャットアプリをマイクロサービスで構築

## やってみた理由
作ってみたかった。
手を動かしてデバックしながら実装することで気づけることがあると思っているため。

# 感想

## frontend
Reactを使用。'socket.io-client'を用いた双方向通信の設定をした。
'socket.io-client'を使うことで簡単に簡単な双方向通信アプリの作成は楽にできた。
具体的には、特定のコンポーネント上で`on`メソッドを使うことで、対応するイベントとの間で通信を行うことができるのですが、この設定を**useEffect内で行っても**問題がないということをすぐに理解できなかった。原因としては、Reactそのものと双方向通信の理解が不十分だったため。

## backend
バックエンドは試したいライブラリが2つあったためそれぞれ実装した。

### Flask-SocketIO
server1はFlask-SocketIOを用いて、Flask環境上でSocket.IOを稼働させている。Flaskのコードは見慣れているため、直感的に理解しやすかった。また、公式ドキュメントも分かりやすかった。
Flaskは認証や認可といった機能を簡単に実装できるライブラリが豊富に提供されているため、短時間でサーバーを構築する際にSocket.IOの対応を加えるには非常に便利だと思った。


### Python-SocketIO(&Tornado)
server2ではPythonフレームワークの非同期通信を行うTornado使ってみたかったため採用した。
しかし実装したところ以下の課題があった

 - TornadoはデフォルトではWebscketプロトコルを使用しており、今回フロントで実装しているSocket.IOプロトコルとは異なるため双方向通信接続ができなかった
 - エラー以外のログを表示しない
 - CORS設定

それぞれ以下で解決した
 - Python-SocketIOライブラリにてSocket.IOプロトコルを使用した
   - そのためTornadoを実装したというよりはPython-SocketIOを使用し、その内部でTornadoサーバーを使用するということになった
     - Tornadoはデフォルトで非同期サポートがあるのと圧倒的なパフォーマンス性能をもっているので、Tornadoをサーバーに利用することは良い調子だと思う。
 - 標準ライブラリのloggingを使用
 - WebSocket通信のCORSとHTTPリクエスト時のCORSの二つの設定が必要だった

## その他
Socket.IOはWebSocketを基礎として以下のような機能を簡単に実装できるようになっていることがわかった。
そのため基本的にはWebsocketプロトコルを使用するのではなくSocket.IOプロトコルを利用するのがいいのだと思った。

- 接続の確立
- 再接続の管理
- 名前空間とルームの概念

しかし想定外でsocketの接続が外れた場合の再接続処理などのエラーハンドリングの実装は行っていない＆わかっていない。

ルームやチャットログを記録する共有リソースとしてのDBの作成を行なっていない。→同一レコードが含まれないようにロックやトランザクション処理が必要になる想定だが、これも実装してみたら新しい課題や気づきがありそう。

# 起動

以下でDocker環境構築
>docker-compose build --no-cache

>docker-compose up -d

## デモ



https://github.com/kenkanayama/Simple-chat-app-using-React-and-Python/assets/44771224/bf40e33c-ad2c-4dce-bbbf-45781c6dd22c


